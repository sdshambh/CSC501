Question 1.The priority inversion problem could cause that a higher-priority process needs to wait for the completion of a lower-priority process.
	1.Priority inheritance is one approach to address this issue. Please give another approach and briefly describe its idea.
	2.Design a test case to show that your approach can address the priority inversion problem. 
	You should compare the results that derived from the original XINU implementation (use semaphore) and that derived from your implementation (use readers/writer locks). 
	Put your results in Lab3Answers.txt and your test case program (name it task1.c) in both ./sys and ./TMP

Solution :

		1.Another approach to address the priority inversion issue is : Priority Ceiling Protocol
		In Priority Ceiling Protocol, the shared resoure is given a predefined priority ceiling. Priority Ceiling implements algorithm that would ensure that each process gets
		the highest priority that is associated with each of the resources held by that process. This priority is temporary and will be replaced with it's original priority on lock release.

		reference: https://www.embedded.com/how-to-use-priority-inheritance/
		
		There are various other approches too such as the one used in microsoft windows to solve the problem of priority inversion , Random Boosting of priorities.
		The implementation randomly picks the process, raises it's priority then runs it's critical section. on exiting critical section restores the original priority of the picked process.

		2.
		Consider the following scenario in test1.c
		Say there are 3 process namely A, B, C with priorities 25,15,35 respectively. Process B is reader to block on writers following it. Process A and C are writers.
		After create, resuming the process in order of  reader,writer,writer(BAC) following happens:
		In semaphore implementation (XINU default): The higher priority task C waits for the other two process to complete as shown in the output below. A acquires the semaphore but since B is higher 
		priority task, it preemts lower priority task thus following the scheduling sqence as B then A then C
		In priority inheritence implementation: B gets scheduled over A as it is the higher priority task (inherited from A) and Then C gets scheduled over A as C is the higher priority task at that time and then A gets
		the chance to run. Thus by inheriting the priorities even though B has lower priority than A, it gets the chance to run. C has higher than the inherited priority. Thus C runs. Then A gets the chance to run. 
		Due to inheritence even though B had lower priority it seemed as the higher priority process acquiring processor while the lock has been acquired actually by lower priority process.
		Thus the sequence of BCA can be seen in the output.
		
		Below is the result (output) from task1.c file
------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		--------------------------Additional Question task1-------------------------

		*****************Implementation of Semaphore*****************
		scheduled reader B
		Process A: acquired semaphore
		scheduled writer A
		scheduled writer C
		B
		B
		B
		B
		B
		Process B: released sem/lck
		A
		A
		A
		A
		A
		Process C: acquired semaphore
		Process A: released semaphore
		C
		C
		C
		C
		C
		Process C: released semaphore
		
		*****************Implementation of Reader/Writer lock*****************
		scheduled reader B
		Process A: acquired lock
		scheduled writer A
		Process C: acquired lock
		scheduled writer C
		B
		B
		B
		B
		B
		Process B: released sem/lck
		C
		C
		C
		C
		C
		Process C: released lock
		A
		A
		A
		A
		A
		Process A: released lock
		task1 ok
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			
Question 2.Synchronization is a quite complex issue in operating systems. To show your understanding about process synchronization, you are asked to point out a reader/writer synchronization issue in this pesudo-code: task2_sync_issue.c. 
Multiple reader threads can execute this code concurrently by calling do_update. All the variables starting with global_ are global variables. 
You are asked to describe the potential issue caused by the incorrect synchronization and point out at least one possible thread interleaving that would trigger the problem.
Put your answer in Lab3Answers.txt mentioned above.

Solution:
			In task2_test_issue code, the do_update() can be called by either reader or writer since both reader and writer can aquire lock and thus the global semaphore. 
			The issue will be in buffer_add function as the locks are not mutually exclusive. Suppose 2-3 readers are accessing the buffer simultaneously and they are preempted by the higher priority writer. 
			The writer can modify the size of the buff leading to erroneous results.
			There lies one more issue,i.e. the order of execution. The order of execution will decide the order of the result. Such scenario is not acceptable in syncronization.
			Example: Say there are 2 readers, both acquired the lock and global semaphore. Suppose the reader1 was preempted by reader2 while updating the buff in buffer_add call. reader2 completes it's update 
			and just when reader1 is about to update the buff, writer preeempts the reader1 and modifies the buffer, thus overwriting the buffer. Such result is undersiable.